# 실시간 정렬의 안정성 확보 : 스냅샷 전략과 배치 도입기
</br>
<img width="1510" height="812" alt="스크린샷 2025-08-03 오후 6 01 48" src="https://github.com/user-attachments/assets/e624cbad-9b0d-402f-aeac-92f224ae8bf1" />

지금까지 진행된 상황입니다. 


가계 목록 조회는 스크롤 방식으로 설계되어있어 사용자는 순차적으로 가계를 탐색합니다.</br>
이런 UX 특성을 고려해 순차 탐색에 적합한 커서 기반 페이징방식을 사용했습니다.</br>

## 주문 많은 순 정렬

주문 많은 순으로 정렬된 가게 목록 조회 API는 호출 빈도가 높기 때문에, 처음에는 단순히 DB I/O를 줄이기 위해 주문횟수를 별도 테이블에 기록하는 방식으로 구현했습니다.

하지만 주문 이벤트가 발생할 때마다 테이블 값이 실시간으로 변동되면서, 사용자에게 일관된 커서 기반 페이징을 보장할 수 없는 문제가 발생했습니다.

이를 해결하기 위해 주문 횟수를 스냅샷 형태로 기록하고, 일정 주기마다 배치 처리를 통해 실시간성을 보정하는 방식으로 접근했습니다.</br>

## 배치처리의 독립성 보장

주문 횟수의 실시간성을 보장하기 위해서는 서비스 운영 중에도 배치처리가 수행되어야 합니다.

배치처리는 서비스에 영향을 주지 않고 독립적으로 실행될 수 있어야 하므로, 최신의 스냅샷 버전을 기록하는 별도의 snapshot_version_meta 테이블을 만들었습니다.

특정 스냅샷 버전에 대한  배치처리가 모두 완료된 후에 latest_committed 속성값을 true로 변경시키는 방식으로, 배치처리와 "주문많은 순" 가게목록조회가 서로 영향을 주지않고 독립적으로 동작합니다.

## 스냅샷 버전의 일관된 읽기 보장

하지만 여기서 끝이 아니었습니다. 

사용자가 가게목록을 조회하는 도중에 새로운 배치 처리가 완료된다면, 주문횟수 데이터가 갱신되면서 목록순서가 달라질 수 있습니다. 즉, 사용자에게 일관된 가게목록 페이징 경험을 제공하기 어렵게 됩니다.

이를 방지하기 위해 프론트에서 snapshot_version 상태를 가지는 방식으로 문제를 해결했습니다.

처음 조회하는 경우(snapshot_version이 null인 경우)에는 최신의 스냅샷 버전으로 데이터를 조회하고, 이후 스크롤중에는 동일한 snapshot_version을 계속 유지해 요청을 보냅니다.

이 방식으로, 새로운 배치가 완료되어 더 최신의 스냅샷 버전의 생성되더라도 현재 조회중인 사용자에게는 일관된 읽기를 보장할 수 있었습니다.

<img width="803" height="503" alt="스크린샷 2025-08-03 오후 7 50 27" src="https://github.com/user-attachments/assets/47f92a37-574d-42ff-8ea8-1867538f4b89" />

## ERD

<img width="716" height="760" alt="스크린샷 2025-08-03 오후 6 16 18" src="https://github.com/user-attachments/assets/8bcc81b3-9053-4ea3-8c78-e79d3c11cb29" />

