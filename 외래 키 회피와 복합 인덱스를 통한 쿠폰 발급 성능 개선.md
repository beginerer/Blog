### 쿠폰 시스템 ERD

<img width="1297" alt="스크린샷 2025-06-21 오전 12 04 06" src="https://github.com/user-attachments/assets/87ba6bc9-9ad1-452a-8225-a4ac799291b2" />  </br>

요구 사항을 기반으로 만들어진 쿠폰 시스템 ERD입니다.

#### CouponIssueService

<img width="884" alt="스크린샷 2025-06-21 오전 11 30 35" src="https://github.com/user-attachments/assets/2a8799ad-58f8-4b23-a65f-a0ded9bdb3a1" />

#### CouponGroup

<img width="744" alt="스크린샷 2025-06-21 오전 11 29 59" src="https://github.com/user-attachments/assets/7d58b173-3de3-4e68-989f-78ad3a0a3583" /> </br>


현재 쿠폰 시스템은 동시성과 데이터 정합성이 중요한 요구사항을 갖고 있습니다. </br>
이를 위해 CouponIssueService의 issue 메서드에서는 비관적 락(PESSIMISTIC_WRITE)을 활용하여 couponGroup 테이블의 레코드에 대해 락을 획득하고, 이후 쿠폰 중복 발급 여부를 검사하기 위한 추가적인 DB조회가 수행됩니다. </br></br>

비관적 락 자체는 성능 최적화가 어려운 구조적 특성을 가지므로, 락 이외의 중복 쿠폰 발급 조회에서 발생하는 DB I/O구간을 최적화 하는것이 쿠폰 발급 성능 개선에 효과적이라고 판단했습니다.</br></br>

특히, 쿠폰 중복 발급 여부를 확인하는 쿼리는 매 발급 요청마다 발생하는 I/O로서 TPS에 직접적인 영향을 주기 때문에 이 쿼리를 최적화 하는것이 실질적인 성능 개선의 핵심이라고 판단했습니다.</br></br>

이를 위해서 먼저 현재의 쿠폰 발급 성능을 측정해보았습니다.</br></br>

jmeter) 1000 threads, 10 second 기준 </br>

<img width="879" alt="querydsl성능" src="https://github.com/user-attachments/assets/3742f17c-5078-4394-8508-3ccf5268c79a" /> </br>
 

<img width="862" alt="querydsl" src="https://github.com/user-attachments/assets/be7b7584-f900-4604-abc2-be3a95028be1" /> </br>


여러 차례 테스트를 진행한 결과, 응답 시간이 우상향 하는 공통된 특징을 발견할 수 있었습니다. 이를 통해 응답 지연을 유발하는 병목 구간이 존재할 가능성을 확인할 수 있었고, 해당 요인을 제거하면 성능 개선이 가능하다고 판단했습니다. </br></br>

<img width="647" alt="스크린샷 2025-06-21 오후 5 04 52" src="https://github.com/user-attachments/assets/ff87336f-0967-4a73-b858-974aa5ea80c5" /> </br>


처음에는 쿠폰 중복 발급 조회에서 N+1 문제가 성능 병목의 원인이라고 생각했었습니다. 
그러나 querydsl이 수행하는 실제 쿼리를 확인해 본결과, N+1 문제가 발생하지 않았습니다. </br></br>

예상과 달리 coupon.couponGroup.couponGroupId에서는 지연로딩으로 인한 추가 쿼리를 발생시키지 않았습니다. 이는  entity 객체 내에서만 발생하는 로직일 뿐, QueryDSL에서는 단순한 ID 기반의 where절 쿼리가 실행되는 것이였습니다.</br></br>

따라서 쿠폰 중복 조회는 성능 병목의 원인이 아닐 수 있다고 생각했고, 다른 원인을 찾아 보기 위해 다양한 자료를 조사해보았습니다. </br></br>

그 과정에서 외래키 제약 조건이 성능 병목의 원인이 될 수 있다는 어느 게시글을 접하게 되었습니다. </br></br>

보다 명확한 이해를 위해, RealMysql도서를 참조하여 외래키 제약조건이 실제로 시스템에 오버헤드를 유발하는지 알아보았습니다. </br></br>

### 외래키 사용의 오버헤드

RealMysql 279쪽을 참조했습니다. </br>

> [!NOTE]
> InnoDB의 외래키 관리에는 중요한 두 가지 특성이 있다.
> - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
> - 외래키와 연관되지 않는 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.
> 
> 자식 테이블의 변경이 대기 하는 경우)
> => 즉 자식 테이블의 외래 키 칼럼의 변경(INSERT,UPDATE)은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 되는 것이다.
> 
> 부모 테이블의 변경 작업이 대기하는 경우)
> => 자식 테이블에 쓰기 잠금이 걸려있는 경우에 부모 테이블이 레코드를 삭제할려는 경우 자식 테이블의 쓰기 잠금이 해제될 때 까지 기달려야 한다.(ON DELETE CASCADE 속성)
> 
> 이처럼 물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 해당 참조키가 부모 테이블에 있는지 확인한다. 
> 추가적으로 이러한 체크를 위해 연관 테이블에 읽기 잠금을 걸어야 한다는 것이다. 또한 이렇게 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리에 영향을 미친다.
</br></br>

현재 쿠폰 시스템에서는 CouponGroup <-> coupon 테이블 간 외래키가 설정된 상태로 coupon 테이블에 INSERT할 때마다 부모테이블인 CouponGroup의 존재여부를 확인하는 과정이 발생합니다. </br></br>

이 작업은 동일 트랜잭션 안에서 수행되어서, 잠금 경합이나 대기상태 (lock wait)는 발생하지 않지만, InnoDB 내부적으로 외래키 무결성 확인을 위한 체크 작업 자체가 오버헤드로 적용했을 수 있다고 생각했습니다.</br></br>

이를 검증하기 위해서 외래키 제약조건을 해제한 상태에서 동일한 조건으로 테스트를 다시 진행해 보았습니다.</br></br>

### CouponGroup과 Coupon 테이블 연관관계 해제 결과

<img width="879" alt="연관관계x" src="https://github.com/user-attachments/assets/cae95875-d3fe-4328-a7db-1efc64b49dde" /> </br>

<img width="861" alt="연관관계x성능" src="https://github.com/user-attachments/assets/bc1cc773-f20a-4499-8355-7b00767eca7a" /> </br>

위 테스트 결과에서 확인할 수 있듯, 약 10%의 성능 향상이 발생하였고,  
이전 테스트에서 보였던 응답 시간의 우상향 경향성도 사라지고 보다 안정적인 응답 시간을 기록했습니다. </br></br>

이를 통해 동일 트랜잭션 안이라도 외래키가 존재하는 테이블에서의 DML의 수행이 성능 병목에 원인이 될 수 있다는 것을 직접적으로 확인할 수 있었습니다. </br>

이번에는 추가적인 성능 향상을 위해 (couponGroupId, userId) 복합인덱스를 추가하고, 다시 테스트를 진행해보았습니다. </br></br>

### 복합 인덱스 사용 테스트 결과

<img width="881" alt="연관관계x 인덱스성능" src="https://github.com/user-attachments/assets/6b25f3c2-04b3-4146-8dd8-4b985ff25c0a" /> </br></br>
<img width="863" alt="연관관계x 인덱스" src="https://github.com/user-attachments/assets/6d529045-8132-48ad-9725-9efba8ec7848" /> </br>

위의 테스트 결과에서 확인할 수 있듯, 기존 대비 약 30%의 추가적인 성능 향상이 나타났습니다. </br>

### 수정된 쿠폰 시스템 ERD

<img width="1334" alt="스크린샷 2025-06-21 오후 6 15 19" src="https://github.com/user-attachments/assets/4fd21cb9-81d1-448d-b262-d81d00a1b329" /> </br>

### 수정된 메서드

<img width="968" alt="스크린샷 2025-06-21 오후 7 35 03" src="https://github.com/user-attachments/assets/c09b6786-0308-4f9d-97c7-a87c5dfca1c7" /> </br>

이번 경험을 통해 데이터의 정합성을 보장해 주는 외래키 제약조건이 처리속도가 중요한 동시성 상황에서는 성능에 부정적 영향을 미칠 수 있다는 사실을 알 게 되었습니다. </br></br>

외래키를 사용하지 않으면 DB layer에서 데이터의 무결성을 보장해주지 않기 때문에 애플리케이션 layer에서 더 주의를 기울여서 데이터의 정합성이 깨지지 않기 위한 올바른 코드의 작성이 더욱 중요해진다는 사실도 느끼게 되었습니다. </br></br>

이번 경험을 교훈삼아 동시성이 중요한 상황에서는 테이블 간 의존관계를 없애는 방식도 고려해볼 것 같습니다. </br></br>

앞으로는 추가적으로 더 공부해서 비관적 락을 사용하는 방식외에도 다양한 락의 방식을 적용해 볼 예정입니다.


