제가 만든 기존의 쿠폰 시스템은 핵심 구조는 갖추고 있지만 실제 비즈니스의 복잡한 요구사항을 충족하기에는 부족하다고 느꼈습니다.

그래서 실제 서비스 환경에서 사용되는 쿠폰시스템을 구현해보면, 현업에서 마주할 수 있는 다양한 고려사항과 문제를 얕게나마 미리 경험해보고, 그것을 해결하는 과정 속에서 개발자로서 한 단계 성장할 수 있을 것이라 생각했습니다.

쿠폰 정책을 사용하는 여러 서비스 회사가 존재하지만, 그중에서도 배달의 민족의 쿠폰시스템을 개인 프로젝트에 적용하면 재밌을 거같다는 생각이 들었습니다.  
</br>
평소 배달의 민족 어플을 자주 사용해서 친숙 하기도 하고, 배달의 민족 가계 사장님 전용 사이트에 쿠폰 정책이 자세하게 설명되어있어 시스템을 구현할때 도움이 많이 될것이라고 생각한 것이 그 이유입니다.
</br></br>

### 배달의 민족 쿠폰 시스템 요구사항

[배달의 민족 쿠폰 정책](https://ceo.baemin.com/guide/3662?one_depth=%ED%95%A0%EC%9D%B8%C2%B7%EB%A7%88%EC%BC%80%ED%8C%85&two_depth=%ED%98%9C%ED%83%9D%C2%B7%EC%BF%A0%ED%8F%B0) 
을 보며 요구사항을 정리해 보았습니다.</br></br>

```
  
0. 각 모든고객혜택의 노출 기간은 중복될 수 없다. 단, 혜택을 제공하는 방식(알뜰배달,한집배달,가계배달, 포장방문)이 서로 다른 경우에 한해 노출 기간을 중복해서 등록 할 수 있다.  

1.동일한 혜택[모든고객,신규,단골] 안에서 노출 기간이 겹치면서 주문 방식이 겹치는 경우는 불가능하다.

2.동일한 혜택[모든고객,신규,단골] 안에서 노출 기간이 겹치더라도, 주문 방식이 다를 경우에는 가능하다. 

3.혜택 시작일은 오늘로 부터 1개월 이내로 설정할 수 있다.  

4.혜택 기간은 시작일로부터 최소 7일, 최대 1년까지 설정할 수 있다.  

5.할인 유형은 정액할인(원)과 정률할인(%)중 선택할 수 있으며, 쿠폰 사용 최소 주문금액 및 할인금액을 다르 설정하여 최대 3개의 쿠폰을 설정할 수 있다.  

6.쿠폰의 유효기간은 14일 또는 30일 중 선택할 수 있다.  

7.고객은 쿠폰을 다운(또는 발급)후 유효기간 내 사용이 가능하다.  
  
8.정액할인은 최소 1000원부터 최대 5000까지 500원 단위로 입력할 수 있다.  

9.정률할은 최소 5%에서 최대 100%까지 설정할 수 있다.  

10.정률할인의 최대할인금은 설정안함이 기본으로 반영된다. 설정함을 선택하는 경우, 최대할인금액은 [쿠폰최소주문금액 X 할인율] 보다 크거나 같은 금액으로 설정할 수 있다.(최소 2,000 ~ 최대 100,000원)  
```
</br>

### 수정된 ERD

<img width="1118" alt="스크린샷 2025-07-03 오후 5 17 12" src="https://github.com/user-attachments/assets/38e2a613-f37c-4a6f-a795-9b9147ba456f" />
</br>

</br></br>
배달의 민족 쿠폰 정책을 보며 주요 요구사항들을 정리했고, 그에 맞춰 기능 구현과 예외 사항 처리를 진행했습니다.

그러다 문득 가계 사장님이 쿠폰 정책을 변경하면, 기존의 쿠폰을 발급받은 유저의 쿠폰은 어떻게 처리해야되는지 의문이 생겼습니다.

단순히 값을 덮어써버리면 데이터의 정합성이 깨지고, 사용자는 의도하지 않은 할인율이나 조건을 적용받을 수 있어 결과적으로 UserExperince에 악영향을 줄 수 있습니다.

게다가, B2C 서비스 기업에서는 UserExperience가 그 무엇보다 중요하기때문에, 이 문제를 어떻게 풀어야 할지 진지하게 고민하게 되었습니다.</br></br>

<img width="764" alt="스크린샷 2025-07-03 오전 12 24 56" src="https://github.com/user-attachments/assets/5ddbac7d-8e98-429c-87b2-07de043c07ca" />
</br></br>

### immutable 한 쿠폰 정책 설계

</br>

이러한 문제를 방지하기 위해, 저는 쿠폰 정책(CouponGroup)은 immutable하게 설계되어야 한다고 생각했습니다. 시스템 오류로 인한 경우가 아니라면 사용자가 발급 받은 쿠폰의 혜택은 보장되어야 한다고 보기 때문입니다.

물론 이런 방식은 쿠폰 정책이 변경될때마다 저장되는 데이터가 늘어난다는 단점이 존재합니다. </br>

그리고 이로 인한 부수효과도 존재했습니다.</br></br>

비지니스 요구사항으로는 할인 유형별 최대 쿠폰 정책을 3개 까지만 등록이 가능한데, 쿠폰 정책이 immutable하게 설계된다면 동일 프로모션 내에서 쿠폰 정책이 여러개 누적될 수 될 수 있습니다. </br>
이에 따라, 현재 사용가능하고, 최신의 쿠폰 정책을 필터링해서 비즈니스 요건에 맞게 최대 3까지 보여주는 별도의 처리과정이 필요합니다.</br></br>

그리고 쿠폰 정책의 변경 과정에 대한 정보를 얻을 수 없기 때문에 사후 분석에 어려움이 존재합니다. (물론 이는 기존의 방식에서도 발생하는 문제라고 생각합니다.)</br></br>

또한 단순히 쿠폰 정책(CouponGroup)데이터만 증가하는 것이 아니라 쿠폰조건(coupon_condtion)과 같은 연관된 테이블의 데이터도 증가해야 하므로 불필요한 저장공간의 낭비와 추가적인 DB I/O가 발생하는 단점이 존재합니다.</br>

</br>

**하지만 저는 무엇보다도 데이터의 정합성과 사용자 경험이 더 중요하다고 판단했습니다.**
</br></br>

대신에 이로 인해 발생하는 부수효과를 어떻게 개선할 수 있을 지 고민해보았습니다.</br></br>

첫째로, 쿠폰 정책이 변경되면 기존의 쿠폰 정책 상태를 INACTIVE로 변경해서 추가적인 쿠폰 발급은 불가능하지만, 이미 발급했던 쿠폰은 사용가능하도록 하는 방식을 생각해 보았습니다.</br></br>

둘째로, immutable로 인해 발생하는 데이터의 증가는 스케줄러를 통해 만료된 정책 및 조건을 정리하는 방식으로 해결할 수 있다고 생각했습니다.</br></br>

셋째로, 연관 테이블의 데이터 증가를 줄이기 위해 조건 테이블(coupon_condition 등)을 공유 테이블로 사용하는 구조를 생각해봤습니다. </br>
즉, couponGroup 과 coupon_condidion이 1대 N 관계에서 N 대1 관계로 변경되는 구조입니다.</br></br>


이러한 방식은 동일 조건을 재사용하기 때문에 저장 효율성이 높습니다. 하지만 실제 시스템 운영 관점에서는 단점이 더 많았습니다. </br></br>

먼저, 이런 방식은 쿠폰정책의 조건에 맞는 레코드를 조회하는 select연산이 필수적으로 수행되는데, 
비즈니스가 복잡해지면서 연관 테이블의 개수나 조건 데이터가(조건 데이터의 증가는 제한적이라고 생각합니다) 늘어날 경우 성능에 부정적인 영향을 줄 수 있습니다. </br>

이를 보완하기위해 커버링 인덱스를 적용해서 조회연산 속도를 향상시킬 수 있겠지만, 이 구조와 기존구조간의 실제 latency 차이는 테스트를 통해 수치적으로 검증해보아야만 정확한 판단을 할수 있다고 생각합니다. </br></br>

또한, 공유 테이블 방식은 조인 연산에 제약을 주기 때문에 비지니스 확장 시 복잡한 쿼리를 작성하는데 어려움이 생길 수 있습니다.</br></br>

마지막으로, 쿠폰 조건의 잘못 변경되거나 삭제될 경우, 해당 조건을 참조하는 모든 쿠폰 정책에 오류가 전파되는 문제가 발생합니다. </br>
비즈니스가 확장되면서 해당 조건을 참조하는 쿠폰 정책 수가 많아질수록,  단일 변경이 전체 시스템에 미치는 영향력이 커지고, 이에 따라 시스템의 불안정이 기하급수적으로 증가합니다. </br></br>

정리하자면 쿠폰 정책은 트래픽이 몰리거나 동시성에 민감한 작업이 아니며, 조인 연산의 유연성을 포기하거나 시스템의 안정성을 위협하면서까지  공유 테이블 방식을 선택할 만큼의 이득은 없다고 판단했습니다. 

따라서 immutable 구조로 인한 연관 테이블의 데이터 증가는 trade-off로 수용하기로 결정했습니다.


### 수정된 ERD

</br>
<img width="1119" alt="스크린샷 2025-07-03 오후 5 21 20" src="https://github.com/user-attachments/assets/1edd7667-0d7c-49e4-bb26-dba02034cc52" /> </br></br>

(1) 쿠폰 그룹에 parentId를 추가해서 정책 변경의 히스토리를 추적가능하게 했습니다.</br></br>
(2) 쿠폰 테이블에 발급 당시의 혜택 정보를 저장해서, 쿠폰 사용시 CouponGroup의 조인연산없이도 할인 계산이 가능하도록 했습니다.</br>

만약 시스템 오류로등으로 인해 쿠폰회수가 필요한 경우에는 Coupon의 status 필드를 통해서 사용불가능한 상태로 전환함으로써 유연하게 대응할 수 있다고 생각했습니다.

### 마치며

이번에는 실제 비즈니스의 쿠폰 시스템을 구현해보는 재밌는 경험을 해보았습니다. 
실제 현업에서 일하는 개발자라는 마음가짐으로 임했는데 그 과정에서 기존에는 미처 인식하지 못했던 문제들을 발견하고 직접 고민해볼 수 있었던 점이 특히 인상 깊었습니다.

이번 경험을 통해, 쿠폰 정책같이 데이터의 정합성과 신뢰성이 중요한 도메인에서는 필드값의 변경으로 인해 기존에 이미 생성된 데이터(쿠폰)에 소급 적용되는 현상을 방지하기 위해서 immutable한 구조로 설계해야된다는 점을 알게 되었습니다.

또한 부족하지만, 이러한 방식으로 설계했을 때의 장단점을 고민해보는 과정도 의미가 있었다고 생각합니다.




